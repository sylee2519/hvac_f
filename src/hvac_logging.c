/*****************************************************************************
 * Author:     Ross G. Miller
 *             Oak Ridge National Lab
 * Date:       04/22/20
 * Purpose:    Functions & structures for logging 
 *
 * Updated:    11/16/20 - Purpose moved to HVAC modified to build without 
 *             warning under C++
 * 
 * Copyright 2020 UT Battelle, LLC
 *
 * This work was supported by the Oak Ridge Leadership Computing Facility at
 * the Oak Ridge National Laboratory, which is managed by UT Battelle, LLC for
 * the U.S. DOE (under the contract No. DE-AC05-00OR22725).
 *
 * This file is part of the HVAC project.
 ****************************************************************************/

#include "hvac_internal.h"
#include "hvac_logging.h"

#include <log4c/appender_type_rollingfile.h>
#include <log4c/rollingpolicy.h>
#include <log4c/rollingpolicy_type_sizewin.h>


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/types.h>
#include <unistd.h>
#include <string.h>



extern __thread bool tl_disable_redirect;

//long param_max_file_size = 5 * 1024 * 1024;  // Value is in bytes
long param_max_file_size = 100 * 1024 * 1024;  // Value is in bytes
long param_max_num_files = 10;
const char *param_layout_to_use = "dated"; // could also be "basic"

void hvac_init_logging()
{
    // Set up the rolling file appender - this code was largely copied from
    // the test_rolling_file_appender.c file in the log4c src tree

    int rc = 0;
    if ( (rc = log4c_init()) != 0 ) {
        fprintf(stderr, "log4c init failed -- error %d -- attempting to continue without the logging system.\n", rc);
        return;
    }

    rollingfile_udata_t *rfup = NULL;
    log4c_rollingpolicy_t *policyp = NULL;
    rollingpolicy_sizewin_udata_t *sizewin_udatap = NULL;

    log4c_category_t* root = NULL;
    log4c_appender_t* file_appender = NULL;

    // Get a reference to the root category (everything inherits from root)
    root = log4c_category_get("root");

    // Note that the log level values range from 0 (LOG4C_PRIORITY_FATAL) to
    // 800 (LOG4C_PRIORITY_TRACE).
    if (getenv(HVAC_LOG_LEVEL))
    {
        int level = atoi(getenv(HVAC_LOG_LEVEL));
        if (level < LOG4C_PRIORITY_FATAL) {
            level = LOG4C_PRIORITY_FATAL;
        } else if (level > LOG4C_PRIORITY_TRACE) {
            level = LOG4C_PRIORITY_TRACE;
        }
        log4c_category_set_priority(root, level);
    } else {
        log4c_category_set_priority(root, LOG4C_PRIORITY_NOTICE);
    }

    // Get a file appender and set the type to rollingfile
    file_appender = log4c_appender_get("aname");
    log4c_appender_set_type(file_appender, log4c_appender_type_get("rollingfile"));


    char *param_log_dir = getenv(HVAC_LOG_DIR);
    if (param_log_dir == NULL) {
        param_log_dir = L4C_LOG_DIR;
    }
    char *param_log_prefix = getenv(HVAC_LOG_PREFIX);
    if (param_log_prefix == NULL) {
        param_log_prefix = L4C_LOG_NAME_PREFIX;
    }

    // Append the PID to the name of the logfile.  (Mostly for the logs
    // generated by the preload library where we might have multiple MPI
    // ranks running on the node, but also useful for the daemon.)
    char *prefix_and_pid = (char *)malloc (strlen(param_log_prefix) + 7);
    // The +7 is 1 byte for the null, 1 for the '.' and 5 for the PID
    sprintf(prefix_and_pid, "%s.%d", param_log_prefix, getpid());

    // Make a rolling file udata object and set the basic parameters 
    rfup = rollingfile_make_udata();              
    rollingfile_udata_set_logdir(rfup, param_log_dir);
    rollingfile_udata_set_files_prefix(rfup, prefix_and_pid);

    free( prefix_and_pid); // don't need this string any more

    // Get a new rollingpolicy
    // type defaults to "sizewin" but set the type explicitly here to show how to do it.
    policyp = log4c_rollingpolicy_get("a_policy_name");
    log4c_rollingpolicy_set_type(policyp, log4c_rollingpolicy_type_get("sizewin"));

    // Get a new sizewin policy type and configure it.  Then attach it to the policy object.
    sizewin_udatap = sizewin_make_udata();
    sizewin_udata_set_file_maxsize(sizewin_udatap, param_max_file_size);
    sizewin_udata_set_max_num_files(sizewin_udatap, param_max_num_files);
    log4c_rollingpolicy_set_udata(policyp,sizewin_udatap);

    // Now set that policy in our rolling file appender udata.
    rollingfile_udata_set_policy(rfup, policyp);
    log4c_appender_set_udata(file_appender, rfup);

    // Allow the rolling policy to initialize itself.
    // It needs to know the rollingfile udata it is associated with--it
    // picks up some parameters in there
    log4c_rollingpolicy_init(policyp, rfup);

    // Configure a layout for the rolling file appender 
    log4c_appender_set_layout(file_appender, log4c_layout_get(param_layout_to_use) );

    // Configure the root category with our rolling file appender...
    // and we can then start logging to it.
    log4c_category_set_appender(root,file_appender );

    // Prints out a bunch of data about how the logging system is configured.
    // (Useful for debugging the logging setup, but not something we normally
    // want to display.)
    // log4c_dump_all_instances(stderr);    
    return;
}

// Right now, this is just a wrapper around log4c_fini().
void HVAC_finalize_logging()
{
    log4c_fini();
}


// Sanity check: The function below uses basename() and needs the GNU implementation
// that is guaranteed to never modify its argument.  If someone has #included libgen.h
// somewhere along the line, we'll get the wrong version (which might sometimes modify
// its argument) and likely introduce some subtle and difficult to reproduce bugs.
#ifdef basename
    #error "Wrong version of basename() has been defined!  Is someone #including libgen.h somewhere?"
#endif


// Like the name says, this function handles some of the initial formatting
// for log messages.  It's intended to be called by the L4C_* macros.
void log_preformatter_internal( unsigned priority, const char* filename, unsigned linenum, const char *format_str, ...)
{
    va_list va_args;
    va_start( va_args, format_str);

    // We can't pass a va_list into any of the log4c functions (at least, not the
    // public-facing ones), so we have to expand format_str ourselves and pass the
    // results into log4c...
    // Yes, this means we're making an extra copy of the message.  No, I don't think
    // the performance impact matters.

    const unsigned MAX_STR_LEN = 1024;
    char expanded_format[MAX_STR_LEN];
    vsnprintf( expanded_format, MAX_STR_LEN, format_str, va_args);

    tl_disable_redirect = true;
    log4c_category_log( log4c_category_get(L4C_CAT_NAME), priority, "[%s:%d] %s",
                        basename(filename), linenum, expanded_format);
    tl_disable_redirect = false;

    // Note: A quick benchmark test showed that calling log4c_category_get() every time
    // (as opposed to calling it once and saving the pointer in a static variable
    // somewhere) slowed the message rate from 108K msg/sec to 101K msg/sec.  Since I
    // don't expect us to get anywhere close to 100K msg/sec, I think the penalty is
    // worth the convenience.

    va_end( va_args);
}
